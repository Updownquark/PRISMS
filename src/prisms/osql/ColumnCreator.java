/*
 * ColumnCreator.java Created Apr 9, 2010 by Andrew Butler, PSL
 */
package prisms.osql;

import java.math.BigDecimal;
import java.sql.*;
import java.sql.ResultSet;

/** Contains logic to parse database columns from database metadata */
public class ColumnCreator
{
	/**
	 * Parses a column from a database metadata result set generated by
	 * {@link DatabaseMetaData#getColumns(String, String, String, String)}
	 * 
	 * @param table The table to get the columns for
	 * @param rs The result set generated by the getColumns method
	 * @return The next column in the result set
	 * @throws PrismsSqlException If the column cannot be parsed
	 */
	@SuppressWarnings("rawtypes")
	public static Column<?> createColumn(BaseTable table, java.sql.ResultSet rs)
		throws PrismsSqlException
	{
		String name;
		int sqlType;
		String sqlTypeName;
		int size;
		int digits;
		Boolean nullable;
		try
		{
			name = rs.getString("COLUMN_NAME");
			sqlType = rs.getInt("DATA_TYPE");
			sqlTypeName = rs.getString("TYPE_NAME");
			size = rs.getInt("COLUMN_SIZE");
			Number digNum = (Number) rs.getObject("DECIMAL_DIGITS");
			digits = digNum == null ? -1 : digNum.intValue();
			int nullInt = rs.getInt("NULLABLE");
			switch(nullInt)
			{
			case java.sql.DatabaseMetaData.columnNoNulls:
				nullable = Boolean.FALSE;
				break;
			case java.sql.DatabaseMetaData.columnNullable:
				nullable = Boolean.TRUE;
				break;
			case java.sql.DatabaseMetaData.columnNullableUnknown:
			default:
				nullable = null;
				break;
			}
		} catch(java.sql.SQLException e)
		{
			throw new PrismsSqlException("Could not query column", e);
		}
		return new Column(table, name, getDataType(sqlType, sqlTypeName, size, digits), size,
			digits, nullable);
	}

	/**
	 * Gets a data type from its SQL representation
	 * 
	 * @param sqlType The SQL data type (see {@link java.sql.Types})
	 * @param typeName The name of the SQL data type
	 * @param size The size of the data column
	 * @param digits The number of decimal digits in the column, if it is numeric
	 * @return The data type for the given SQL type
	 */
	public static DataType<?> getDataType(int sqlType, String typeName, int size, int digits)
	{
		switch(sqlType)
		{
		case Types.ARRAY:
			return new UnhandledDataType(typeName, sqlType);
		case Types.BIGINT:
			return new BigDecimalDataType(typeName, sqlType, false);
		case Types.BINARY:
		case Types.BIT:
		case Types.BLOB:
		case Types.VARBINARY:
		case Types.LONGVARBINARY:
			return new BlobDataType(typeName, sqlType);
		case Types.BOOLEAN:
			return new BooleanDataType(typeName, sqlType);
		case Types.CHAR:
			return new CharDataType(typeName, sqlType);
		case Types.VARCHAR:
			if(size <= 10000)
				return new VarcharDataType(typeName, sqlType);
			else
				return new ClobDataType(typeName, sqlType);
		case Types.LONGVARCHAR:
		case Types.CLOB:
			return new ClobDataType(typeName, sqlType);
		case Types.DATALINK:
			return new UnhandledDataType(typeName, sqlType);
		case Types.DATE:
		case Types.TIME:
		case Types.TIMESTAMP:
			return new DateDataType(typeName, sqlType);
		case Types.DECIMAL:
			return new BigDecimalDataType(typeName, sqlType, digits > 0);
		case Types.DISTINCT:
			return new UnhandledDataType(typeName, sqlType);
		case Types.INTEGER:
			return new IntDataType(typeName, sqlType);
		case Types.DOUBLE:
		case Types.FLOAT:
		case Types.REAL:
			return new FloatDataType(typeName, sqlType);
		case Types.NUMERIC:
			if(digits == 0 && size <= 22)
				return new LongIntDataType(typeName, sqlType);
			else
				return new BigDecimalDataType(typeName, sqlType, digits > 0);
		case Types.JAVA_OBJECT:
			return new UnhandledDataType(typeName, sqlType);
		case Types.OTHER:
			return new UnhandledDataType(typeName, sqlType);
		case Types.REF:
			return new UnhandledDataType(typeName, sqlType);
		case Types.SMALLINT:
			return new ShortIntDataType(typeName, sqlType);
		case Types.STRUCT:
			return new UnhandledDataType(typeName, sqlType);
		case Types.TINYINT:
			return new ByteDataType(typeName, sqlType);
		default:
			return new UnhandledDataType(typeName, sqlType);
		}
	}

	/** Represents SQL data types that are not handled by this API */
	public static class UnhandledDataType implements DataType<Object>
	{
		private final String theName;

		private final int theSqlType;

		UnhandledDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<Object> getJavaType()
		{
			return Object.class;
		}

		public String getPrettyName()
		{
			return "other";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public Object get(ResultSet rs, String colName, Column<Object> column)
			throws PrismsSqlException
		{
			throw new PrismsSqlException("Data type " + theName + " unsupported");
		}

		public boolean isStringable(Object value, Column<Object> column)
		{
			throw new IllegalStateException("The data type " + theName
				+ " is unsupported by PRISMS OSQL");
		}

		public void toSQL(Object value, StringBuilder ret, Column<Object> column)
		{
			throw new IllegalStateException("The data type " + theName
				+ " is unsupported by PRISMS OSQL");
		}

		public void setParam(Object value, PreparedStatement stmt, int paramIdx,
			Column<Object> column) throws SQLException
		{
			throw new IllegalStateException("The data type " + theName
				+ " is unsupported by PRISMS OSQL");
		}
	}

	/** Represents a boolean type */
	public static class BooleanDataType implements DataType<Boolean>
	{
		private final String theName;

		private final int theSqlType;

		BooleanDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<Boolean> getJavaType()
		{
			return Boolean.class;
		}

		public String getPrettyName()
		{
			return "boolean";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public Boolean get(ResultSet rs, String colName, Column<Boolean> column)
			throws PrismsSqlException
		{
			try
			{
				return Boolean.valueOf(rs.getBoolean(colName));
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get boolean", e);
			}
		}

		public boolean isStringable(Boolean value, Column<Boolean> column)
		{
			return true;
		}

		public void toSQL(Boolean value, StringBuilder ret, Column<Boolean> column)
		{
			if(value == null)
				ret.append("NULL");
			else
				ret.append(prisms.util.DBUtils.boolToSql(value.booleanValue()));
		}

		public void setParam(Boolean value, PreparedStatement stmt, int paramIdx,
			Column<Boolean> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setBoolean(paramIdx, value.booleanValue());
		}
	}

	/** Represents a constant-length character sequence type */
	public static class CharDataType implements DataType<String>
	{
		private final String theName;

		private final int theSqlType;

		CharDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<String> getJavaType()
		{
			return String.class;
		}

		public String getPrettyName()
		{
			return "char";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public String get(ResultSet rs, String colName, Column<String> column)
			throws PrismsSqlException
		{
			try
			{
				return rs.getString(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get chars", e);
			}
		}

		public boolean isStringable(String value, Column<String> column)
		{
			return true;
		}

		public void toSQL(String value, StringBuilder ret, Column<String> column)
		{
			ret.append(prisms.util.DBUtils.toSQL(value));
		}

		public void setParam(String value, PreparedStatement stmt, int paramIdx,
			Column<String> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setString(paramIdx, value);
		}
	}

	/** Represents a variable-length character sequence type */
	public static class VarcharDataType implements DataType<String>
	{
		private final String theName;

		private final int theSqlType;

		VarcharDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<String> getJavaType()
		{
			return String.class;
		}

		public String getPrettyName()
		{
			return "varchar";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public String get(ResultSet rs, String colName, Column<String> column)
			throws PrismsSqlException
		{
			try
			{
				return rs.getString(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get varchar", e);
			}
		}

		public boolean isStringable(String value, Column<String> column)
		{
			return true;
		}

		public void toSQL(String value, StringBuilder ret, Column<String> column)
		{
			ret.append(prisms.util.DBUtils.toSQL(value));
		}

		public void setParam(String value, PreparedStatement stmt, int paramIdx,
			Column<String> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setString(paramIdx, value);
		}
	}

	/** Represents a byte */
	public static class ByteDataType implements DataType<Byte>
	{
		private final String theName;

		private final int theSqlType;

		ByteDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<Byte> getJavaType()
		{
			return Byte.class;
		}

		public String getPrettyName()
		{
			return "byte";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public Byte get(ResultSet rs, String colName, Column<Byte> column)
			throws PrismsSqlException
		{
			Number val;
			try
			{
				val = (Number) rs.getObject(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get byte", e);
			}
			if(val == null)
				return null;
			else if(val instanceof Byte)
				return (Byte) val;
			else
				return Byte.valueOf(val.byteValue());
		}

		public boolean isStringable(Byte value, Column<Byte> column)
		{
			return true;
		}

		public void toSQL(Byte value, StringBuilder ret, Column<Byte> column)
		{
			if(value.byteValue() < 0)
				ret.append(value.byteValue() + 256);
			else
				ret.append(value.byteValue());
		}

		public void setParam(Byte value, PreparedStatement stmt, int paramIdx, Column<Byte> column)
			throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setByte(paramIdx, value.byteValue());
		}
	}

	/** Represents a short integer data type */
	public static class ShortIntDataType implements DataType<Short>
	{
		private final String theName;

		private final int theSqlType;

		ShortIntDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<Short> getJavaType()
		{
			return Short.class;
		}

		public String getPrettyName()
		{
			return "short";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public Short get(ResultSet rs, String colName, Column<Short> column)
			throws PrismsSqlException
		{
			Number val;
			try
			{
				val = (Number) rs.getObject(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get short int", e);
			}
			if(val == null)
				return null;
			else if(val instanceof Short)
				return (Short) val;
			else
				return Short.valueOf(val.shortValue());
		}

		public boolean isStringable(Short value, Column<Short> column)
		{
			return true;
		}

		public void toSQL(Short value, StringBuilder ret, Column<Short> column)
		{
			if(value == null)
				ret.append("NULL");
			else
				ret.append(value);
		}

		public void setParam(Short value, PreparedStatement stmt, int paramIdx, Column<Short> column)
			throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setShort(paramIdx, value.shortValue());
		}
	}

	/** Represents an integer data type */
	public static class IntDataType implements DataType<Integer>
	{
		private final String theName;

		private final int theSqlType;

		IntDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<Integer> getJavaType()
		{
			return Integer.class;
		}

		public String getPrettyName()
		{
			return "int";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public Integer get(ResultSet rs, String colName, Column<Integer> column)
			throws PrismsSqlException
		{
			Number val;
			try
			{
				val = (Number) rs.getObject(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get int", e);
			}
			if(val == null)
				return null;
			else if(val instanceof Integer)
				return (Integer) val;
			else
				return Integer.valueOf(val.intValue());
		}

		public boolean isStringable(Integer value, Column<Integer> column)
		{
			return true;
		}

		public void toSQL(Integer value, StringBuilder ret, Column<Integer> column)
		{
			if(value == null)
				ret.append("NULL");
			else
				ret.append(value);
		}

		public void setParam(Integer value, PreparedStatement stmt, int paramIdx,
			Column<Integer> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setInt(paramIdx, value.intValue());
		}
	}

	/** Represents a long integer data type */
	public static class LongIntDataType implements DataType<Long>
	{
		private final String theName;

		private final int theSqlType;

		LongIntDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<Long> getJavaType()
		{
			return Long.class;
		}

		public String getPrettyName()
		{
			return "long";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public Long get(ResultSet rs, String colName, Column<Long> column)
			throws PrismsSqlException
		{
			Number val;
			try
			{
				val = (Number) rs.getObject(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get long int", e);
			}
			if(val == null)
				return null;
			else if(val instanceof Long)
				return (Long) val;
			else
				return Long.valueOf(val.longValue());
		}

		public boolean isStringable(Long value, Column<Long> column)
		{
			return true;
		}

		public void toSQL(Long value, StringBuilder ret, Column<Long> column)
		{
			if(value == null)
				ret.append("NULL");
			else
				ret.append(value);
		}

		public void setParam(Long value, PreparedStatement stmt, int paramIdx, Column<Long> column)
			throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setLong(paramIdx, value.longValue());
		}
	}

	/** Represents a floating-point data type */
	public static class FloatDataType implements DataType<Double>
	{
		private final String theName;

		private final int theSqlType;

		FloatDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<Double> getJavaType()
		{
			return Double.class;
		}

		public String getPrettyName()
		{
			return "float";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public Double get(ResultSet rs, String colName, Column<Double> column)
			throws PrismsSqlException
		{
			Number val;
			try
			{
				val = (Number) rs.getObject(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get float", e);
			}
			if(val == null)
				return null;
			else if(val instanceof Double)
				return (Double) val;
			else
				return Double.valueOf(val.doubleValue());
		}

		public boolean isStringable(Double value, Column<Double> column)
		{
			return true;
		}

		public void toSQL(Double value, StringBuilder ret, Column<Double> column)
		{
			if(value == null)
				ret.append("NULL");
			else
				ret.append(value);
		}

		public void setParam(Double value, PreparedStatement stmt, int paramIdx,
			Column<Double> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setDouble(paramIdx, value.doubleValue());
		}
	}

	/** Represents a numeric data type that is too large for java's long or double types */
	public static class BigDecimalDataType implements DataType<java.math.BigDecimal>
	{
		private final String theName;

		private final int theSqlType;

		private final boolean fractional;

		BigDecimalDataType(String name, int sqlType, boolean frac)
		{
			theName = name;
			theSqlType = sqlType;
			fractional = frac;
		}

		public String getSqlName()
		{
			return theName;
		}

		public String getPrettyName()
		{
			return "bigdecimal";
		}

		public Class<BigDecimal> getJavaType()
		{
			return BigDecimal.class;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public BigDecimal get(ResultSet rs, String colName, Column<java.math.BigDecimal> column)
			throws PrismsSqlException
		{
			Number val;
			try
			{
				val = (Number) rs.getObject(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get big decimal", e);
			}
			if(val == null)
				return null;
			else if(val instanceof BigDecimal)
				return (BigDecimal) val;
			else if(fractional)
				return new BigDecimal(val.doubleValue());
			else
				return new BigDecimal(val.longValue());
		}

		public boolean isStringable(BigDecimal value, Column<java.math.BigDecimal> column)
		{
			return true;
		}

		public void toSQL(BigDecimal value, StringBuilder ret, Column<java.math.BigDecimal> column)
		{
			ret.append(value);
		}

		public void setParam(BigDecimal value, PreparedStatement stmt, int paramIdx,
			Column<java.math.BigDecimal> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setBigDecimal(paramIdx, value);
		}
	}

	/** Represents a timestamp or date data type */
	public static class DateDataType implements DataType<java.util.Date>
	{
		/** A constant to write the current date */
		public static final java.util.Date CURRENT = new java.util.Date(-1);

		private final String theName;

		private final int theSqlType;

		DateDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public Class<java.util.Date> getJavaType()
		{
			return java.util.Date.class;
		}

		public String getPrettyName()
		{
			return "date";
		}

		public String getSqlName()
		{
			return theName;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public java.util.Date get(ResultSet rs, String colName, Column<java.util.Date> column)
			throws PrismsSqlException
		{
			try
			{
				return rs.getDate(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get date", e);
			}
		}

		public boolean isStringable(java.util.Date value, Column<java.util.Date> column)
		{
			return true;
		}

		public void toSQL(java.util.Date value, StringBuilder ret, Column<java.util.Date> column)
		{
			if(value == null)
				ret.append("NULL");
			else if(value == CURRENT)
				try
				{
					int len = ret.length();
					switch(column.getTable().getConnection().getType())
					{
					case MYSQL:
						ret.append("NOW()");
						break;
					case MSSQL:
						ret.append("GETDATE()");
						break;
					case ORACLE:
						ret.append("SYSDATE");
						break;
					case HSQL:
						ret.append("CURRENT_TIMESTAMP");
						break;
					case POSTGRES:
						ret.append("current_timestamp");
						break;
					case SYBASE:
						ret.append("getdate()");
						break;
					case INFORMIX:
						ret.append("CURRENT()");
						break;
					case UNKNOWN:
						throw new IllegalStateException(
							"Cannot use current date with unrecognized connection brand "
								+ column.getTable().getConnection().getType());
					}
					if(len == ret.length())
						throw new IllegalStateException(
							"Cannot use current date with unrecognized connection brand "
								+ column.getTable().getConnection().getType());
				} catch(PrismsSqlException e)
				{
					throw new IllegalStateException("Could not get connection type", e);
				}
			else
				ret.append(value);
		}

		public void setParam(java.util.Date value, PreparedStatement stmt, int paramIdx,
			Column<java.util.Date> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else if(value instanceof java.sql.Date)
				stmt.setDate(paramIdx, (java.sql.Date) value);
			else
				stmt.setDate(paramIdx, new java.sql.Date(value.getTime()));
		}
	}

	/** Represents a binary streamable data type */
	public static class BlobDataType implements DataType<java.io.InputStream>
	{
		private final String theName;

		private final int theSqlType;

		BlobDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public String getSqlName()
		{
			return theName;
		}

		public String getPrettyName()
		{
			return "binary stream";
		}

		public Class<java.io.InputStream> getJavaType()
		{
			return java.io.InputStream.class;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public java.io.InputStream get(ResultSet rs, String colName,
			Column<java.io.InputStream> column) throws PrismsSqlException
		{
			try
			{
				return rs.getBinaryStream(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get blob data", e);
			}
		}

		public boolean isStringable(java.io.InputStream value, Column<java.io.InputStream> column)
		{
			return value == null;
		}

		public void toSQL(java.io.InputStream value, StringBuilder ret,
			Column<java.io.InputStream> column)
		{
			if(value == null)
				ret.append("NULL");
			else
				throw new IllegalArgumentException(
					"Non-null input blobs cannot be written to SQL inline");
		}

		public void setParam(java.io.InputStream value, PreparedStatement stmt, int paramIdx,
			Column<java.io.InputStream> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setBinaryStream(paramIdx, value);
		}
	}

	/** Represents a character streamable data type */
	public static class ClobDataType implements DataType<java.io.Reader>
	{
		private final String theName;

		private final int theSqlType;

		ClobDataType(String name, int sqlType)
		{
			theName = name;
			theSqlType = sqlType;
		}

		public String getSqlName()
		{
			return theName;
		}

		public String getPrettyName()
		{
			return "long string";
		}

		public Class<java.io.Reader> getJavaType()
		{
			return java.io.Reader.class;
		}

		public int getSqlType()
		{
			return theSqlType;
		}

		public java.io.Reader get(ResultSet rs, String colName, Column<java.io.Reader> column)
			throws PrismsSqlException
		{
			try
			{
				return rs.getCharacterStream(colName);
			} catch(SQLException e)
			{
				throw new PrismsSqlException("Could not get clob data", e);
			}
		}

		public boolean isStringable(java.io.Reader value, Column<java.io.Reader> column)
		{
			return value == null;
		}

		public void toSQL(java.io.Reader value, StringBuilder ret, Column<java.io.Reader> column)
		{
			if(value == null)
				ret.append("NULL");
			else
				throw new IllegalArgumentException(
					"Non-null input clobs cannot be written to SQL inline");
		}

		public void setParam(java.io.Reader value, PreparedStatement stmt, int paramIdx,
			Column<java.io.Reader> column) throws SQLException
		{
			if(value == null)
				stmt.setNull(paramIdx, theSqlType);
			else
				stmt.setCharacterStream(paramIdx, value);
		}
	}
}
